泛型入门
java集合有一个缺点，我们把对象放进集合里面后，再次取出来该对象的时候，该对象的编译类型就变成了＂Ｏｂｊｅｃｔ＂类型（运行时类型没有变）．
因为最初设计集合的人不会知道我们想要用集合来保存什么类型的对象．因此设计为了能保存任何类型的对象，这样有两个问题：
１．如果想创建只存Ａ对象的集合，程序也可以轻易扔进去Ｃ对象，有可能引发异常
２，取出来元素集合的时候，通常需要强制转换，可能引发ＣｌａｓｓＣａｓｔＥｘｃｅｐｔｉｏｎ
因此，我们使用泛型来解决该问题，就能创建只保存某一个类型的集合：这样集合扔不进去其他类型，取出对象的时候也无需强制转换．
举例　List<String> ls = new ArrayList<String>();

所谓泛型：就是允许在定义类.接口时指定类型形参
创建了一个定义带泛型声明的类Apple<T>类,实际使用Apple类时,会为T这个形参传入实际的参数类型,这样就可以生成<String><Integer>等,这就是List接口
的子类可以使用泛型的原因
因为发型后面可以加不同类型的参数,从而可以将很多实际相同的类当做许多不同的类来处理.同时,类的静态变量与方法也在所有实例间共享,因此,静态相关
的声明和初始化不允许使用泛型形参.
由于系统也不会真正生层泛型类,所以instanceof运算符后面也不能使用泛型


泛型通配符
为了表示各种泛型的父类,我们需要使用类型通配符"?",可以匹配任何类型.比如说Collection<?>代表未知类型元素的List,其他的set,map同理.
但是通配符只能作为各个泛型的父类,并不能把元素加入其中

设定通配符的上限
List<? extends Shape>就是一个受限通配符的例子,这句话代表我们知道这个未知类型是Shap的一个子类(或者本身),也就是说Shape当成了这个通配符上限.
同时注意的是:因为这是代表一个子类,具体是什么不知道,所以我们不能把对象添加到这种(限制通配符的)集合中.

设置类型形参的上限
泛型不仅可以使用通配符设置类型上限,也可以在定义类型形参时设定上限,比如<T extends Number>,实际参数只能是Number或者其子类,还可以极端地设置多
上限,



泛型方法
